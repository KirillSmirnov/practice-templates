from os import getenv
import subprocess
import sys
from dotenv import load_dotenv
from langchain_gigachat.chat_models import GigaChat
from langchain_core.messages import HumanMessage, SystemMessage, ToolMessage
from langchain_core.tools import tool

rules = [
    "1. Отдавайте предпочтение разрешающим лицензиям. Код мы рекомендуем лицензировать под Apache License 2.0, MIT License, BSD 3-Clause License.",
    "2. Каждая лицензия имеет требования к тому, как её правильно применить к файлам в репозитории. Например, Apache License 2.0 позволяет себя применять пофайлово, для чего требует включения в лицензируемые файлы стандартного заголовка. Также распространено использование файла LICENSE в корне репозитория и ссылка на него в заголовке каждого файла. Поищите для своей лицензии, как её правильно применять.",
    "3. Если используете чужую интеллектуальную собственность, найдите на неё лицензию и проверьте, что вы действительно выполняете её требования (например, проект, лицензированный под Apache License 2.0 не может использовать код, лицензированный под GPL v2). Если чужой материал не имеет лицензии (например, просто картинка из интернета или кусок кода со Stack Overflow), использовать его нельзя",
    "4. Если вы используете GitHub, Continuous Integration-систему удобнее всего настраивать на GitHub Actions, однако вполне допустимы и сторонние системы, такие как AppVeyor, CircleCI. Если вы используете компилируемые языки, CI-система должна проверять собирабельность кода в каждой ветке репозитория и при пуллреквесте. Если интерпретируемые, проверять качество кода и работоспособность",
    "5. В проекте должны быть модульные тесты (за редкими исключениями, где они неприменимы или бессмысленны), и модульные тесты должны запускаться в CI.",
    "6. Должен быть настроен форматтер/линтер, следящий за качеством кода, и также запускаться в CI. Если линтер выдаёт ошибки, сборка должна не проходить. Например, для F# линтер — это FSharpLint, для Python — flake8, форматтер для F# — это Fantomas, для Python — black. Нет ничего плохого в том, чтобы использовать форматтер и линтер в CI, настроенные так, чтобы некачественный код даже не доходил до фазы сборки.",
    "7. Запуск линтера может быть отдельной задачей в CI, чтобы не гонять его по нескольку раз в разных конфигурациях сборки.",
    "8. Имеет смысл сделать запуск линтера локальным pre-commit hook в git, чтобы некорректный код даже не позволяли закоммитить. Если есть возможность интегрировать среду разработки и линтер/форматтер, сделайте это. Например, Visual Studio Code легко подружить с Fantomas, чтобы он запускался при каждом сохранении файла и делал как надо.",
    "9. На GitHub файл .gitignore можно выбрать при создании репозитория, но также часто требуется ручная модификация. Должно быть так, чтобы все файлы, которые .gitignore позволяет закоммитить, реально нужно было коммитить. В репозитории не должно быть результатов сборки, (то есть папок bin, obj, pycache и т.п.), в идеале не должно быть бинарных файлов вовсе (только если очень надо и вы реально знаете, что делаете).",
    "10. Разумеется, в репозитории (включая историю коммитов) не должно быть ничего, что вы не хотели бы публиковать (например, ключей авторизации от сообществ ВКонтакте). Если пользуетесь GitHub, кое-что он умеет ловить сам, для этого надо убедиться, что в «Settings/Code security and analysis» включено «Push protection». Но, разумеется, большую часть секретов он не найдёт.",
    "11. Используйте сторонние анализаторы для слежения за качеством кода: например, CodeCov для анализа тестового покрытия, CodeFactor или Codacy как продвинутый статический анализатор. Чем больше инструментов следят за тем, что всё хорошо, тем лучше.",
    "12. Языки типа С и С++ дают возможности для работы на низком уровне, но благодаря этому повышается вероятность появления таких ошибок, как небезопасная работа с памятью или undefined behavior. Поэтому для проектов на этих языках стоит включать санитайзеры при сборке, тестировать санитайзерами на CI, а также запускать инструменты для отслеживания утечек памяти (например, Valgrind).",
    "13. Добавьте в README.md плашки CI и анализаторов (штучки, на которых написано «CI passing» или что-то такое). В документации конкретной CI-системы или анализатора обычно легко найти, как добавить плашку в Markdown. Это поможет посетителям сразу посмотреть статус кода.",
    "14. Напишите в README.md пару абзацев текста, про что вообще проект. Помните, что код вы пишете не только для себя, в ваш репозиторий придут люди, которые вообще не имеют идей, о чём это.",
    "15. Опишите типичный пример использования, если уместно, с картинками или gif-ками. Включая информацию, откуда брать датасеты, куда подкладывать конфигурацию и т.п., чтобы любой пользователь мог с чистого листа запустить проект и понять, что у него получилось.",
    "16. Опишите также действия по сборке и внешние зависимости (версию используемых SDK и т.п.). Это всё есть в CI, но в README это всё должно быть в удобной человекочитаемой форме и заодно приводить к развёртыванию окружения, пригодного для работы над проектом (тогда как сборка в CI может быть весьма хитрой, использовать несколько Docker-образов и т.п.).",
    "17. Если проект предполагает возможность стороннего участия (то есть имеет хоть один шанс стать знаменитым), опишите, как сторонний человек может вам помочь: куда и как писать баги; как связаться с разработчиками; как контрибьютить; где посмотреть техническую документацию и найти первый вводный баг, который можно поправить.",
    "18. Названия каких-либо организаций, используемых инструментов или технологий должны быть написаны так же, как в официальных источниках (пример: TRIK Studio, а не Trik Studio, RISC-V, а не RISC-5).",
    "19. Оформите секцию About: стоит добавить подходящие темы (topics), чтобы ваш репозиторий было легче найти, и описание (description), чтобы стороннему человеку было понятно, зачем репозиторий нужен (кратко, одним предложением — подробное описание в README.md).",
    "20. Проверьте, что код в репозитории адекватно оформлен. Если на Python, то PEP-8, если на C++, то в соответствии с Core Guidelines и т.п. — у каждого языка и даже у некоторых фреймворков есть свой стиль кодирования, проверьте, что код его уважает. Если в проекте используется свой стиль кодирования, он должен быть явно задокументирован и весь код должен ему соответствовать.",
    "21. Где-то должно быть некое техническое описание проекта — из каких компонентов он состоит, кто за что отвечает. В идеале — полноценная архитектурная документация в виде страниц на вики, с UML-диаграммами, но если сил нет, можно ограничиться разделом в README, где кратко словами всё описать. Также вместе с/вместо вики может быть уместна документация на Read The Docs.",
    "22. В коде должны быть комментарии (в принятом для языка формате — DocString, Doxygen, Javadoc, XML Documentation и т.п.), хотя бы у ключевых классов/интерфейсов/модулей, кратко описывающие, что вообще делает класс. В идеале — для всего, что public, с документированием предположений о входных данных, инвариантов, бросаемых исключений и свойств потокобезопасности (reentrant, thread-safe и т.п.), но насколько сил хватит. В идеале — по комментариям в коде должна автоматически генерироваться документация и выкладываться на GitHub Pages или тот же Read The Docs (в т.ч. как действие при сборке в CI, то есть полностью автоматически). Например, Для Python есть инструмент Sphinx, который в этом помогает.",
    "23. Комментарии к коммитам пост-фактум исправить тяжело, поэтому за ними надо следить изначально. Рекомендуется следовать соглашению Conventional Commits. Коммиты не должны быть сделаны в последний день, а должны показывать, как шла работа, от создания пустого проекта до последнего релиза. Фразы вида «я тут локально разрабатывал, потом выложил, как получилось что-то разумное» очень сильно огорчают комиссию. Могут помочь инструменты типа Mergeable, Mergify.",
    "24. Почистите главную ветку репозитория от лишнего. Если у вас в репозитории больше пяти маловменяемых комментариев (типа «fix») подряд, либо несколько коммитов отвечают за небольшие изменения одной и той же функциональности, лучше либо сделайте squash и склейте коммиты в один, либо измените всю историю через git rebase -i.",
    "25. Если ваш проект позиционируется как библиотека, игра или какой-либо независимый инструмент, рекомендуется публиковать новые версии в качестве релизов, т.к. они предоставляют пользователям удобный способ доступа к конкретным версиям вашего проекта и информации о том, что именно изменено или добавлено в каждой версии. Рекомендуется ознакомиться со стандартами оформления релизов и Semantic versioning.",
    "26. Рекомендуется настроить правила защиты веток (например, запретить force push в main), а также инструменты безопасности и анализа кода (обновление зависимостей через Dependabot, инструмент CodeQL для автоматического обнаружения распространенных уязвимостей и ошибок в коде).",
]

repo = ""


@tool
def git_log() -> str:
    """
    Возвращает первые 8192 байтов git log текущего репозитория
    """
    result = subprocess.run(
        ["git", "-C", repo, "log"], check=True, capture_output=True, text=True
    )
    return (result.stdout)[:8192]


@tool
def fs_tree() -> str:
    """
    Возвращает дерево файлов в проекте. Каждая строка содержит относительный путь к одному файлу.
    """

    result = subprocess.run(
        ["find", repo, "-type", "f"], check=True, capture_output=True, text=True
    )
    res = list(map(lambda x: x[len(repo) :], result.stdout.split("\n")))
    return "\n".join(res)


@tool
def file_content(name: str) -> str:
    """
    Возвращает первые 4096 символов из текстового файле по указанному относительному пути.

    Args:
        name: относительный путь к файлу
    """
    with open(repo + "/" + name, "r", encoding="utf-8") as f:
        log = f.read()
    return log[:4096]


tools_map = {
    "git_log": git_log,
    "fs_tree": fs_tree,
    "file_content": file_content,
}


def check_rule(model, rule: str):
    sm = SystemMessage(
        content="""Представь, что ты инструмент, который анализирует репозиторий с кодом на предмет соответствия неким формальным правилам, которые тебе будут передавать в запросах.
У меня есть для тебя набор инструментов, с помощью которых ты можешь взаимодействовать с кодом. Если тебе не хватает информации, воспользуйся инструментами. Фантазировать и придумывать факты запрещено. Не надо советовать выполнять некоторые пункты вручную. Например, если нужно открыть файл и проверить наличие определенной строки, сделай это самостоятельно, у тебя для этого есть инструменты.
Тщательно проверь проект на соответствие правилам, которые будут в запросе.
"""
    )
    lastm = HumanMessage(
        content="По результатам этого диалога укажи свое мнение, выполнены ли требования правил или нет. Напиши одну строку с ответом и больше ничего. Возможные варианты ответа: точно выполнены, скорее выполнены, не хватает данных для оценки, скорее невыполнены, точно невыполнены."
    )
    messages = [
        sm,
        HumanMessage(content=rule),
    ]
    verbose = ""
    budget = 7  # Limit LLM curiosity
    while budget > 0:
        budget -= 1
        result = model.invoke(messages)
        messages.append(result)
        verbose += result.content
        tc = result.tool_calls
        if len(tc) == 0:
            break
        for t in tc:
            try:
                r = tools_map[t["name"]].invoke(t["args"])
                messages.append(ToolMessage(content=r, tool_call_id=t["id"]))
            except Exception as e:
                messages.append(
                    ToolMessage(content=str(e), tool_call_id=t["id"], status="error")
                )

    messages.append(lastm)
    result = model.invoke(messages)
    return [result.content, verbose]


def format_result(result) -> None:
    print("Сводка:")
    i = 1
    for r in result:
        print(f"{i}. {r[0]}")
        i += 1
    print("==========================")
    print("Подробности")
    i = 0
    for r in result:
        print(rules[i])
        print("---Ответ нейросети---")
        print(r[1])
        print("---------------------------------------")
        i += 1


def main() -> None:
    load_dotenv()

    if len(sys.argv) == 1:
        print(f"Usage {sys.argv[0]} <path to repo>")
        sys.exit(0)

    global repo  # pylint: disable=global-statement
    repo = sys.argv[1]

    model = GigaChat(
        credentials=getenv("GIGACHAT_CREDENTIALS"),
        scope="GIGACHAT_API_PERS",
        model="GigaChat-2-PRO",
        verify_ssl_certs=False,  # For dev
        # ca_bundle_file="trusted-root-ca.pem",  # For prod
        timeout=60,
        temperature=0.4,
    )
    model_with_tools = model.bind_tools([git_log, fs_tree, file_content])

    result = []
    limit = len(rules)  # Для тестов можно взять 3 или 4
    for rule in rules:
        if limit == 0:
            break
        r = check_rule(model_with_tools, rule)
        result.append(r)
        limit -= 1

    format_result(result)


if __name__ == "__main__":
    main()
